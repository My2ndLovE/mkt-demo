// Prisma Schema for Multi-Level Agent Lottery Sandbox System
// Database: Azure SQL Database (SQL Server)
// ORM: Prisma v5

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlserver"
  url      = env("DATABASE_URL")
}

// ============================================================================
// CORE ENTITIES
// ============================================================================

/// User entity representing Admin, Moderator, and Agent roles
/// Supports unlimited hierarchy depth via self-referential upline/downlines
model User {
  id              Int       @id @default(autoincrement())
  username        String    @unique @db.NVarChar(50)
  passwordHash    String    @db.NVarChar(255)
  role            String    @db.NVarChar(20) // ADMIN, MODERATOR, AGENT
  fullName        String    @db.NVarChar(100)
  contactNumber   String?   @db.NVarChar(20)
  email           String?   @db.NVarChar(100)

  // Hierarchy (Self-referential for unlimited levels)
  // SQL Server requires NoAction for self-referential relations
  upline          User?     @relation("UserHierarchy", fields: [uplineId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  uplineId        Int?
  downlines       User[]    @relation("UserHierarchy")

  // Moderator Organization (for data isolation)
  moderatorId     Int?
  moderator       User?     @relation("ModeratorAgents", fields: [moderatorId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  managedAgents   User[]    @relation("ModeratorAgents")

  // Weekly Limits (using MONEY type for currency precision)
  weeklyLimit     Decimal   @default(0) @db.Money
  weeklyUsed      Decimal   @default(0) @db.Money
  commissionRate  Decimal   @default(0) @db.Decimal(5,2) // 0.00 to 100.00

  // Status & Metadata
  active          Boolean   @default(true)
  lastLoginAt     DateTime? @db.DateTime
  createdAt       DateTime  @default(now()) @db.DateTime
  updatedAt       DateTime  @updatedAt @db.DateTime

  // Relations
  bets            Bet[]     @relation("UserBets")
  commissions     Commission[] @relation("CommissionRecipient")
  auditLogs       AuditLog[]
  refreshTokens   RefreshToken[]
  limitResets     LimitResetLog[]

  @@index([uplineId])
  @@index([moderatorId])
  @@index([username])
  @@index([role])
  @@index([active])
  @@index([createdAt])
  @@map("User")
}

/// Service Provider (Lottery operators)
model ServiceProvider {
  id              Int       @id @default(autoincrement())
  code            String    @unique @db.NVarChar(10) // M, P, T, S
  name            String    @db.NVarChar(100)
  active          Boolean   @default(true)

  // API Configuration (for result synchronization)
  apiEndpoint     String?   @db.NVarChar(500)
  apiKey          String?   @db.NVarChar(500) // Encrypted with AES-256-GCM

  // Metadata
  createdAt       DateTime  @default(now()) @db.DateTime
  updatedAt       DateTime  @updatedAt @db.DateTime

  // Relations
  bets            Bet[]
  results         DrawResult[]

  @@index([code])
  @@index([active])
  @@map("ServiceProvider")
}

/// Bet placed by user (Multi-provider support via JSON array)
model Bet {
  id                Int       @id @default(autoincrement())

  // User who placed the bet
  userId            Int
  user              User      @relation("UserBets", fields: [userId], references: [id])

  // Provider (single for indexing, but providerIds JSON for multi-provider)
  providerId        Int
  provider          ServiceProvider @relation(fields: [providerId], references: [id])
  providerIds       String    @db.NVarChar(Max) // JSON: ["M", "P", "T"]

  // Bet Details
  betNumber         String    @db.NVarChar(20)
  betType           String    @db.NVarChar(20) // STRAIGHT, BOX, PERMUTATION
  amountPerProvider Decimal   @db.Money
  totalAmount       Decimal   @db.Money

  // Draw Information
  drawDate          DateTime? @db.DateTime
  status            String    @default("PENDING") @db.NVarChar(20) // PENDING, WON, LOST, CANCELLED

  // Result Information (populated after draw)
  resultId          Int?
  result            DrawResult? @relation(fields: [resultId], references: [id])
  winAmount         Decimal   @default(0) @db.Money

  // Moderator (for row-level security)
  moderatorId       Int?

  // Cancellation tracking
  cancelledAt       DateTime? @db.DateTime

  // Metadata
  createdAt         DateTime  @default(now()) @db.DateTime
  updatedAt         DateTime  @updatedAt @db.DateTime

  // Relations
  commissions       Commission[]

  @@index([userId])
  @@index([providerId])
  @@index([status])
  @@index([drawDate])
  @@index([moderatorId])
  @@index([createdAt])
  @@index([userId, status])
  @@map("Bet")
}

/// Draw Results from lottery operators
model DrawResult {
  id              Int       @id @default(autoincrement())

  // Provider Information
  providerId      Int
  provider        ServiceProvider @relation(fields: [providerId], references: [id])

  // Draw Details
  drawNumber      String    @db.NVarChar(50)
  drawDate        DateTime  @db.DateTime

  // Winning Numbers (comma-separated)
  winningNumbers  String    @db.NVarChar(Max)
  specialNumbers  String?   @db.NVarChar(Max)

  // Metadata
  createdAt       DateTime  @default(now()) @db.DateTime
  updatedAt       DateTime  @updatedAt @db.DateTime

  // Relations
  bets            Bet[]

  @@unique([providerId, drawNumber])
  @@index([providerId])
  @@index([drawDate])
  @@index([drawNumber])
  @@index([providerId, drawDate])
  @@map("DrawResult")
}

/// Commission records for hierarchy
model Commission {
  id              Int       @id @default(autoincrement())

  // Recipient of this commission
  userId          Int
  user            User      @relation("CommissionRecipient", fields: [userId], references: [id])

  // Bet that generated this commission
  betId           Int
  bet             Bet       @relation(fields: [betId], references: [id])

  // Commission Calculation
  commissionRate  Decimal   @db.Decimal(5,2)
  commissionAmount Decimal  @db.Money

  // Moderator (for row-level security)
  moderatorId     Int?

  // Metadata
  createdAt       DateTime  @default(now()) @db.DateTime

  @@index([userId])
  @@index([betId])
  @@index([moderatorId])
  @@index([createdAt])
  @@index([userId, createdAt])
  @@map("Commission")
}

// ============================================================================
// AUTHENTICATION & SESSION
// ============================================================================

/// Refresh tokens for JWT authentication
model RefreshToken {
  id              Int       @id @default(autoincrement())
  userId          Int
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  token           String    @unique @db.NVarChar(500)
  expiresAt       DateTime  @db.DateTime
  createdAt       DateTime  @default(now()) @db.DateTime
  revokedAt       DateTime? @db.DateTime

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("RefreshToken")
}

// ============================================================================
// AUDIT & LOGGING
// ============================================================================

/// Audit log for security and compliance
model AuditLog {
  id              Int       @id @default(autoincrement())

  // User who performed the action
  userId          Int?
  user            User?     @relation(fields: [userId], references: [id])

  // Action Details
  action          String    @db.NVarChar(100)
  entity          String    @db.NVarChar(50)
  entityId        Int?
  details         String?   @db.NVarChar(Max) // JSON

  // Request Context
  ipAddress       String?   @db.NVarChar(50)
  userAgent       String?   @db.NVarChar(500)

  // Moderator (for row-level security)
  moderatorId     Int?

  // Timestamp
  timestamp       DateTime  @default(now()) @db.DateTime

  @@index([userId])
  @@index([action])
  @@index([entity])
  @@index([timestamp])
  @@index([moderatorId])
  @@map("AuditLog")
}

/// Weekly limit reset log
model LimitResetLog {
  id              Int       @id @default(autoincrement())
  userId          Int
  user            User      @relation(fields: [userId], references: [id])

  resetDate       DateTime  @db.DateTime
  previousUsed    Decimal   @db.Money
  newUsed         Decimal   @db.Money

  createdAt       DateTime  @default(now()) @db.DateTime

  @@index([userId])
  @@index([resetDate])
  @@index([createdAt])
  @@map("LimitResetLog")
}
